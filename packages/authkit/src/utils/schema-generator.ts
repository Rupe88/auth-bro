import { DatabaseProvider } from '../types';

export class SchemaGenerator {
  /**
   * Generate complete Prisma schema for authentication
   */
  static generate(provider: DatabaseProvider): string {
    const datasourceConfig = this.getDatasourceConfig(provider);

    return `// This file was generated by AuthKit
// Do not edit manually - regenerate using: npx authkit generate-schema

${datasourceConfig}

model User {
  id            String    @id @default(cuid())
  email         String?   @unique
  emailVerified Boolean   @default(false)
  phone         String?   @unique
  phoneVerified Boolean   @default(false)
  password      String?

  // Profile
  name          String?
  avatar        String?
  role          Role      @default(USER)

  // Security
  twoFactorEnabled Boolean @default(false)
  twoFactorSecret  String?

  // Metadata
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  lastLoginAt   DateTime?

  // Relations
  accounts      Account[]
  sessions      Session[]
  verificationTokens VerificationToken[]

  @@index([email])
  @@index([phone])
  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String  // oauth, email
  provider          String  // google, github, credentials
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  userId       String
  refreshToken String   @unique
  userAgent    String?
  ipAddress    String?
  expiresAt    DateTime
  createdAt    DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([refreshToken])
  @@map("sessions")
}

model VerificationToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  type      TokenType
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@map("verification_tokens")
}

enum Role {
  USER
  ADMIN
  MODERATOR
  @@map("roles")
}

enum TokenType {
  EMAIL_VERIFICATION
  PASSWORD_RESET
  PHONE_VERIFICATION
  TWO_FACTOR
  MAGIC_LINK
  @@map("token_types")
}`;
  }

  /**
   * Get datasource configuration for different providers
   */
  private static getDatasourceConfig(provider: DatabaseProvider): string {
    const configs = {
      postgresql: `generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}`,
      mysql: `generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}`,
      sqlite: `generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}`,
      sqlserver: `generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlserver"
  url      = env("DATABASE_URL")
}`,
      mongodb: `generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}`,
      cockroachdb: `generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "cockroachdb"
  url      = env("DATABASE_URL")
}`
    };

    return configs[provider] || configs.postgresql;
  }

  /**
   * Generate environment variables template
   */
  static generateEnvTemplate(provider: DatabaseProvider): string {
    const dbUrls = {
      postgresql: 'postgresql://username:password@localhost:5432/authkit_db?schema=public',
      mysql: 'mysql://username:password@localhost:3306/authkit_db',
      sqlite: './dev.db',
      sqlserver: 'sqlserver://localhost:1433;database=authkit_db;user=username;password=password',
      mongodb: 'mongodb://localhost:27017/authkit_db',
      cockroachdb: 'postgresql://username:password@localhost:26257/authkit_db?schema=public'
    };

    return `# Database
DATABASE_URL="${dbUrls[provider]}"

# JWT
JWT_SECRET="your-super-secret-jwt-key-min-32-chars"

# OAuth Providers (optional)
GOOGLE_CLIENT_ID=""
GOOGLE_CLIENT_SECRET=""
GITHUB_CLIENT_ID=""
GITHUB_CLIENT_SECRET=""

# Email Provider (optional)
RESEND_API_KEY=""
EMAIL_FROM="noreply@yourapp.com"

# Phone/SMS Provider (optional)
TWILIO_ACCOUNT_SID=""
TWILIO_AUTH_TOKEN=""
TWILIO_PHONE_NUMBER=""

# App Configuration
NODE_ENV="development"
APP_URL="http://localhost:3000"`;
  }

  /**
   * Generate Docker Compose configuration
   */
  static generateDockerCompose(provider: DatabaseProvider): string {
    const services: Record<DatabaseProvider, string> = {
      postgresql: `version: '3.8'
services:
  db:
    image: postgres:15
    restart: always
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: authkit_db
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:`,

      mysql: `version: '3.8'
services:
  db:
    image: mysql:8
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: password
      MYSQL_DATABASE: authkit_db
      MYSQL_USER: user
      MYSQL_PASSWORD: password
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql

volumes:
  mysql_data:`,

      sqlite: `# SQLite doesn't need Docker Compose
# Database file will be created automatically`,

      sqlserver: `version: '3.8'
services:
  db:
    image: mcr.microsoft.com/mssql/server:2022-latest
    restart: always
    environment:
      ACCEPT_EULA: Y
      SA_PASSWORD: StrongPassword123!
      MSSQL_DB: authkit_db
    ports:
      - "1433:1433"
    volumes:
      - sqlserver_data:/var/opt/mssql

volumes:
  sqlserver_data:`,

      mongodb: `version: '3.8'
services:
  db:
    image: mongo:7
    restart: always
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: password
      MONGO_INITDB_DATABASE: authkit_db
    ports:
      - "27017:27017"
    volumes:
      - mongo_data:/data/db

volumes:
  mongo_data:`,

      cockroachdb: `version: '3.8'
services:
  db:
    image: cockroachdb/cockroach:v23.1.0
    restart: always
    command: start-single-node --insecure --listen-addr=0.0.0.0:26257 --http-addr=0.0.0.0:8080
    ports:
      - "26257:26257"
      - "8080:8080"
    volumes:
      - cockroach_data:/cockroach/cockroach-data

volumes:
  cockroach_data:`
    };

    return services[provider];
  }

  /**
   * List all supported providers
   */
  static getSupportedProviders(): DatabaseProvider[] {
    return ['postgresql', 'mysql', 'sqlite', 'sqlserver', 'mongodb', 'cockroachdb'];
  }

  /**
   * Validate provider
   */
  static isValidProvider(provider: string): provider is DatabaseProvider {
    return this.getSupportedProviders().includes(provider as DatabaseProvider);
  }
}
